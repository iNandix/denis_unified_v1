#!/usr/bin/env python3
"""Stream 5: Neuro-layers â†” Mental-loops integration smoke test.

This test verifies REAL integration between neurolayers and mental-loops:
1. CognitiveEventBus emits events when neurolayers process
2. Events are routed to appropriate mental-loops
3. GraphWriter records all interactions in Neo4j
4. Feedback flows back from mental-loops to neurolayers
"""

import argparse
import json
import sys
from pathlib import Path
from datetime import datetime, timezone

PROJECT_ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(PROJECT_ROOT))


def _utc_now() -> str:
    return datetime.now(timezone.utc).isoformat()


def parse_args():
    parser = argparse.ArgumentParser(
        description="Stream 5: Neuro-mental loop integration smoke"
    )
    parser.add_argument(
        "--out-json",
        default="artifacts/architecture/neuro_loop_links.json",
        help="Output artifact path",
    )
    return parser.parse_args()


def run_smoke():
    """Run neuro-mental loop integration smoke test with REAL event bus."""
    try:
        # Test 1: Import cognitive integration module
        print("Testing cognitive_integration import...")
        from denis_unified_v1.cognitive_integration import (
            CognitiveEventBus,
            NeuroMentalIntegrationService,
            get_integration_service,
            get_cognitive_event_bus,
            NeuroLayerEventType,
            FeedbackType,
        )

        # Test 2: Initialize integration service
        print("Initializing integration service...")
        integration_service = get_integration_service()
        event_bus = get_cognitive_event_bus()

        # Test 3: Emit events and verify routing
        print("Testing event emission and routing...")
        test_events = [
            {
                "neurolayer": "L1_SENSORY",
                "event_type": "sensory_input",
                "data": {"input": "visual"},
            },
            {
                "neurolayer": "L2_WORKING",
                "event_type": "working_update",
                "data": {"context": "test"},
            },
            {
                "neurolayer": "L3_EPISODIC",
                "event_type": "episodic_encode",
                "data": {"memory": "event"},
            },
            {
                "neurolayer": "L9_IDENTITY",
                "event_type": "identity_update",
                "data": {"self": "update"},
            },
        ]

        emitted_events = []
        for test_event in test_events:
            event = integration_service.emit_cognitive_event(
                neurolayer=test_event["neurolayer"],
                event_type=test_event["event_type"],
                data=test_event["data"],
            )
            emitted_events.append(
                {
                    "id": event.id,
                    "source": event.source_neurolayer,
                    "target": event.target_mental_loop,
                    "graph_recorded": event.graph_recorded,
                }
            )
            print(f"  Event: {test_event['neurolayer']} -> {event.target_mental_loop}")

        # Test 4: Check integration status
        print("Checking integration status...")
        status = integration_service.get_integration_status()
        print(f"  Active integrations: {len(status.get('active_integrations', []))}")
        print(f"  Pending feedback: {status.get('pending_feedback', 0)}")
        print(f"  Total events: {status.get('total_events', 0)}")

        # Test 5: Check pending feedback (should have been generated by mental-loop processors)
        print("Checking feedback generation...")
        feedback = integration_service.get_pending_feedback()
        print(f"  Generated feedback items: {len(feedback)}")

        # Test 6: Verify graph writer can record
        print("Testing graph writer...")
        from denis_unified_v1.memory.graph_writer import get_graph_writer

        graph_writer = get_graph_writer()

        # Test direct graph recording
        graph_result = graph_writer.record_neurolayer_mental_loop(
            neurolayer="L1_SENSORY",
            mental_loop="reflection",
            feedback_type="smoke_test",
        )

        # Test 7: Verify relationships in Neo4j
        print("Verifying Neo4j relationships...")
        verification = verify_relationships()

        # Determine overall status
        integration_ok = (
            len(emitted_events) == len(test_events)
            and verification.get("neo4j_available", False) == True
        )

        return {
            "ok": True,
            "status": "integrated" if integration_ok else "partial",
            "timestamp_utc": _utc_now(),
            "tests_passed": {
                "module_import": True,
                "service_init": True,
                "event_emission": len(emitted_events) == len(test_events),
                "event_routing": all(e["target"] is not None for e in emitted_events),
                "feedback_generation": len(feedback) > 0,
                "graph_recording": verification.get("neo4j_available", False),
                "relationships_exist": verification.get("feeds_feedbacks_exist", False),
            },
            "event_results": emitted_events,
            "integration_status": status,
            "feedback_generated": feedback[:3] if feedback else [],
            "verification": verification,
        }

    except Exception as e:
        import traceback

        return {
            "ok": False,
            "status": "failed",
            "error": f"Smoke test execution failed: {str(e)}",
            "traceback": traceback.format_exc()[:500],
            "timestamp_utc": _utc_now(),
        }


def verify_relationships() -> dict:
    """Verify that neuro-mental relationships exist in Neo4j."""
    try:
        import os

        uri = os.getenv("NEO4J_URI", "bolt://10.10.10.1:7687")
        user = os.getenv("NEO4J_USER", "neo4j")
        password = os.getenv("NEO4J_PASSWORD", "")

        if not password:
            return {"neo4j_available": False, "reason": "NEO4J_PASSWORD not set"}

        from neo4j import GraphDatabase

        driver = GraphDatabase.driver(uri, auth=(user, password))

        with driver.session() as session:
            feed_query = """
            MATCH ()-[r:FEEDS|FEEDBACKS]-()
            RETURN count(r) as relationship_count
            """
            feed_result = session.run(feed_query).single()
            feeds_feedbacks_count = feed_result["relationship_count"]

            mental_chain_query = """
            MATCH path = (ml1:MentalLoopLevel)-[:NEXT*]->(ml2:MentalLoopLevel)
            RETURN count(path) > 0 as chain_exists
            """
            mental_result = session.run(mental_chain_query).single()
            mental_chain_exists = mental_result["chain_exists"]

            neuro_chain_query = """
            MATCH path = (nl1:NeuroLayer)-[:NEXT*]->(nl2:NeuroLayer)
            RETURN count(path) > 0 as chain_exists
            """
            neuro_result = session.run(neuro_chain_query).single()
            neuro_chain_exists = neuro_result["chain_exists"]

        driver.close()

        return {
            "neo4j_available": True,
            "feeds_feedbacks_exist": feeds_feedbacks_count > 0,
            "feeds_feedbacks_count": feeds_feedbacks_count,
            "mental_loop_chain_exists": mental_chain_exists,
            "neurolayer_chain_exists": neuro_chain_exists,
        }

    except Exception as e:
        return {"neo4j_available": False, "error": str(e)[:200]}


def main():
    args = parse_args()
    result = run_smoke()

    out_path = Path(args.out_json)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open("w", encoding="utf-8") as f:
        json.dump(result, f, indent=2)

    print(json.dumps(result, indent=2))
    return 0


if __name__ == "__main__":
    sys.exit(main())
